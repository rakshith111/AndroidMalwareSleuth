import os
import requests
from threading import Thread, Lock
from queue import Queue
from tqdm import tqdm


lock = Lock()
q = Queue()


def download_file(url, dest_folder, pbar):
    try:
        response = requests.get(url, timeout=10, stream=True)
        file_name = os.path.basename(url)

        with lock:
            if not os.path.exists(dest_folder):
                os.makedirs(dest_folder)

        with open(os.path.join(dest_folder, file_name), 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
        with lock:
            pbar.update(1)
        print(f"Downloaded {url.split('/')[-1]} ")
    except Exception as e:
        print(f"Error downloading {url}: {e}")


def worker(pbar):
    while True:
        item = q.get()
        if item is None:
            break
        url, dest_folder = item
        download_file(url, dest_folder, pbar)
        q.task_done()


def check_existing_files(urls, dest_folder):
    if os.path.exists(dest_folder):
        base_addres = urls[1].split('/')[:-1]
        base_address = "/".join(base_addres)

        existing_files = set(f for f in os.listdir(dest_folder))

        target_files = set([urls.split('/')[-1].split('?')[0]
                           for urls in urls])

        urls = [base_address + '/' + f
                for f in target_files - existing_files]
        print(f"Found {len(existing_files)} existing files.")

    return urls


def main(input_file, num_threads=10):
    dest_folder = os.path.splitext(input_file)[0]

    with open(input_file) as f:
        urls = [line.strip() for line in f.readlines()]
    print(f"Found {len(urls)} files to download.")
    urls = check_existing_files(urls, dest_folder)
    print(f"Downloading {len(urls)} files to {dest_folder}...")

    for url in urls:
        q.put((url, dest_folder))

    threads = []
    with tqdm(total=len(urls), desc="Downloading files") as pbar:
        for _ in range(num_threads):
            t = Thread(target=worker, args=(pbar,))
            t.start()
            threads.append(t)

        for _ in range(num_threads):
            q.put(None)

        for t in threads:
            t.join()

    print("Download complete.")


if __name__ == "__main__":
    input_file = r"Scrapper\test.txt"
    num_threads = 10
    main(input_file, num_threads)

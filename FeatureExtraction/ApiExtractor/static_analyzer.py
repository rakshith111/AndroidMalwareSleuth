import os
import subprocess
import argparse
import platform
import json
from typing import List, Optional
from libsast import Scanner


from _base_logger import logger
from _base_logger import error_logger
from jadx_updator import download_latest_jadx


def process_input_folder(app_dir: str) -> List[str]:
    '''
    Finds all the APKs in a directory and genrates full path to each APK
    '''
    if not os.path.exists(app_dir):
        logger.error("[-] The folder does not exist.")
        return
    if not os.path.isdir(app_dir):
        logger.error("[-] The provided path is not a folder.")
        return

    logger.info('[+] Looking for APKs in: {}'.format(app_dir))
    apk_list = []
    for root, dirs, files in os.walk(app_dir):
        for file in files:
            if file.endswith('.apk'):
                apk_list.append(os.path.join(root, file))
                logger.info('[+] Found APK: {}'.format(file))
    logger.info('[+] Total APKs found: {}'.format(len(apk_list)))
    return apk_list


def apk_to_java(folder: List[str], output_dir: str, exec_path: Optional[str] = None, additional_args: Optional[str] = None):
    '''
    Converts APK to Java using Jadx
    '''
    if not os.path.exists(exec_path):
        logger.error("[-] Jadx executable not found.")
        return
    if not os.path.exists(output_dir):
        logger.error("[-] Output directory does not exist.")
        logger.info('[+] Creating output directory: {}'.format(output_dir))
        os.makedirs(output_dir)

    foldernames = []

    for apk in folder:

        foldername = os.path.basename(apk)
        foldername = os.path.splitext(foldername)[0]
        # Clean up filename
        foldername = foldername.replace(' ', '_')
        # Create temp folder for each APK
        current_apk_output_dir = os.path.join(output_dir, foldername)
        if not os.path.exists(current_apk_output_dir):
            os.makedirs(current_apk_output_dir)

        logger.info('[+] Converting APK to Java: {}'.format(foldername))

        # args=[ exec_path, '--deobf', '--deobf-min', '3', '--deobf-max', '64', '--deobf-use-sourcename', '--deobf-parse-kotlin-metadata', '--deobf-res-name-source', 'auto', '--use-kotlin-methods-for-var-names', 'apply', '--rename-flags', 'all', '-d', os.path.join(output_dir, filename), apk]

        if additional_args is None:
            command = [exec_path, '-ds', current_apk_output_dir,
                       '-r',
                       '--show-bad-code',
                       "--deobf",
                       apk]
        else:
            command = [exec_path, '-ds', current_apk_output_dir,
                       '-r',
                       '--show-bad-code',
                       "--deobf",
                       apk, additional_args]

        with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
            for line in proc.stdout:
                logger.info(line.decode().strip())
            for line in proc.stderr:
                error_logger.error(line.decode().strip())
        logger.info(
            '[+] Finished converting APK to Java: {}'.format(foldername))
        foldernames.append((current_apk_output_dir, foldername))
    return foldernames


def format_findings(findings, root):
    """Format findings."""
    for details in findings.values():
        tmp_dict = {}
        for file_meta in details['files']:
            file_meta['file_path'] = file_meta[
                'file_path'].replace(root, '', 1)
            file_path = file_meta['file_path']
            start = file_meta['match_lines'][0]
            end = file_meta['match_lines'][1]
            if start == end:
                match_lines = start
            else:
                exp_lines = []
                for i in range(start, end + 1):
                    exp_lines.append(i)
                match_lines = ','.join(str(m) for m in exp_lines)
            if file_path not in tmp_dict:
                tmp_dict[file_path] = str(match_lines)
            elif tmp_dict[file_path].endswith(','):
                tmp_dict[file_path] += str(match_lines)
            else:
                tmp_dict[file_path] += ',' + str(match_lines)
        details['files'] = tmp_dict
    return findings


def scan(rule: str, extensions: str, paths: list, ignore_paths: list) -> dict:
    '''
    Args:
        rule (str): rule file path
        extensions (str): extensions to scan
        paths (list): list of paths to scan
        ignore_paths (list): list of paths to ignore
    Returns:
        dict: findings
    '''
    try:
        options = {
            'match_rules': rule,
            'match_extensions': extensions,
            'ignore_paths': ignore_paths,
            'show_progress': True}
        scanner = Scanner(options, paths)
        res = scanner.scan()
        if res:
            return format_findings(res['pattern_matcher'], paths[0])
    except Exception:
        logger.exception('libsast scan')
    return {}


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description="Process a folder.")
    parser.add_argument(
        "--folder", "--f",  help="Input Path to folder of APKs to be processed", type=str, required=True)
    parser.add_argument(
        "--output", "--o",  help="Output Path to folder of APKs to be processed", type=str, required=False)
    parser.add_argument("--update", "--u",  help="Update jadx to latest version",
                        type=bool, default=True, required=False)
    parser.add_argument("--additional", "--a",
                        help="Additional arguments to be passed to jadx", type=str, default=None, required=False)
    args = parser.parse_args()
    download_latest_jadx(False)
    if platform.system() == 'Windows':
        EXEC_PATH = os.path.join(
            os.getcwd(), 'FeatureExtraction', 'libs', 'jadx', 'bin', 'jadx.bat')
    elif platform.system() == 'Linux':
        EXEC_PATH = os.path.join(
            os.getcwd(), 'FeatureExtraction', 'libs', 'jadx', 'bin', 'jadx')
    if args.output is None:
        OUTPUT_DIR = os.path.join(os.getcwd(), 'FeatureExtraction', 'Output')
    else:
        OUTPUT_DIR = args.output
    SKIP_CLASS_PATH = {
        'com/google/', 'androidx', 'okhttp2/', 'okhttp3/',
        'com/android/', 'com/squareup', 'okhttp/'
        'android/content/', 'com/twitter/', 'twitter4j/',
        'android/support/', 'org/apache/', 'oauth/signpost',
        'android/arch', 'org/chromium/', 'com/facebook',
        'org/spongycastle', 'org/bouncycastle',
        'com/amazon/identity/', 'io/fabric/sdk',
        'com/instabug', 'com/crashlytics/android',
        'kotlinx/', 'kotlin/', 'com/google/gson/', 'com/google/firebase/', 'com/google/ads/',
        'com/branch/sdk/', 'io/sentry/',
        'io/underscope/',
        'org/jsoup/', 'org/joda/', 'org/greenrobot/',
    }

    api_rules = os.path.join(
        os.getcwd(), 'FeatureExtraction', 'libs', 'Mobfs_api_ref', 'android_apis.yaml')

    apk_list = process_input_folder(args.folder)
    java_output_folders = apk_to_java(apk_list, output_dir=OUTPUT_DIR,
                                      exec_path=EXEC_PATH, additional_args=args.additional)

    for java_output_folder in java_output_folders:
        findings = scan(rule=api_rules, extensions=['.java', '.kt'], paths=[
                        java_output_folder[0]], ignore_paths=SKIP_CLASS_PATH)
        with open(os.path.join(OUTPUT_DIR, java_output_folder[1] + '.json'), 'w') as f:
            json.dump(findings, f, indent=4)

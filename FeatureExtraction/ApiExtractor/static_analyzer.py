import os
import sys
import json
import shutil
import subprocess
import pathlib
import argparse
import platform
import concurrent.futures

from typing import List, Optional
from libsast import Scanner

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

from libs._base_logger import logger, error_logger
from libs.color import bcolors
from ApiExtractor.jadx_updator import download_latest_jadx

EXEC_PATH=None
SKIP_CLASS_PATH = {
        'com/google/', 'androidx', 'okhttp2/', 'okhttp3/',
        'com/android/', 'com/squareup', 'okhttp/'
        'android/content/', 'com/twitter/', 'twitter4j/',
        'android/support/', 'org/apache/', 'oauth/signpost',
        'android/arch', 'org/chromium/', 'com/facebook',
        'org/spongycastle', 'org/bouncycastle',
        'com/amazon/identity/', 'io/fabric/sdk',
        'com/instabug', 'com/crashlytics/android',
        'kotlinx/', 'kotlin/', 'com/google/gson/', 'com/google/firebase/', 'com/google/ads/',
        'com/branch/sdk/', 'io/sentry/',
        'io/underscope/',
        'org/jsoup/', 'org/joda/', 'org/greenrobot/',
    }
API_RULES = os.path.join(
     'FeatureExtraction', 'libs', 'Mobfs_api_ref', 'android_apis.yaml')

def set_exec_path() -> str:
    '''
    Sets the path to jadx executable based on the OS

    '''
    global EXEC_PATH
    if platform.system() == 'Windows':
        EXEC_PATH = os.path.join(
             'FeatureExtraction', 'libs', 'jadx', 'bin', 'jadx.bat')
    elif platform.system() == 'Linux':
        EXEC_PATH = os.path.join(
            'FeatureExtraction', 'libs', 'jadx', 'bin', 'jadx')
    return EXEC_PATH

def process_input_folder(app_dir: str) -> List[str]:
    ''' 
    Finds all the APKs in a directory and genrates full path to each APK

    Args:
        app_dir (str): path to folder containing APKs
        Returns:
            list: list of APKs

    '''
    if not os.path.exists(app_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] The folder does not exist.{bcolors.ENDC}')
        return
    if not os.path.isdir(app_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] The provided path is not a folder.{bcolors.ENDC}')
        return

    logger.info(
        f'{bcolors.OKBLUE}[+] Looking for APKs in: {app_dir}{bcolors.ENDC}')
    apk_list = []
    for root, dirs, files in os.walk(app_dir):
        for file in files:
            if file.endswith('.apk'):
                # MAKE IT POSIX PATH
                apk_list.append(pathlib.PurePath(root, file).as_posix())
                logger.info(
                    f'{bcolors.OKBLUE}[+] Found APK: {file}{bcolors.ENDC}')
    logger.info(
        f'{bcolors.OKBLUE}[+] Total APKs found: {len(apk_list)}{bcolors.ENDC}')
    return apk_list


def cleanfolder(folder: List[str]):
    '''
    Cleans up the folder

    Args:
        folder (list): list of folders
    '''
    for paths in folder:
        shutil.rmtree(paths[0])
        logger.info(
            f'{bcolors.OKGREEN}[+] Deleted folder: {paths[1]}{bcolors.ENDC}')

def apk_to_java_single(apk: str, output_dir: str, exec_path: Optional[str] = None, additional_args: Optional[str] = None) -> str:
    foldername = os.path.basename(apk)

    foldername = os.path.splitext(foldername)[0]+'_API'
    foldername = foldername.replace(' ', '_')
    current_apk_output_dir = os.path.join(output_dir, foldername)
    if not os.path.exists(current_apk_output_dir):
        os.makedirs(current_apk_output_dir)

    logger.info(f'{bcolors.OKBLUE}[+] Converting APK to Java: {foldername}{bcolors.ENDC}')

    if additional_args is None:
        command = [exec_path, '-ds', current_apk_output_dir, '-r', '--show-bad-code', '--deobf', apk]
    else:
        command = [exec_path, '-ds', current_apk_output_dir, '-r', '--show-bad-code', '--deobf', apk, additional_args]

    with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        for line in proc.stdout:
            logger.info(f'{bcolors.OKGREEN}{line.decode().strip()}{bcolors.ENDC}')
        for line in proc.stderr:
            error_logger.error(f'{bcolors.FAIL}{line.decode().strip()}{bcolors.ENDC}')
    logger.info(f'{bcolors.OKBLUE}[+] Finished converting APK to Java: {foldername}{bcolors.ENDC}')
    return (current_apk_output_dir, foldername)

def apk_to_java(folder: List[str], output_dir: str, exec_path: Optional[str] = None, additional_args: Optional[str] = None) -> List[str]:
    '''
        Converts APK to Java using Jadx

        Args:   
            folder (list): list of APKs
            output_dir (str): output directory
            exec_path (str): path to jadx executable
            additional_args (str): additional arguments to pass to jadx
        Returns:
            list: list of folder names
    '''
    if not os.path.exists(exec_path):
        error_logger.error(
            f'{bcolors.FAIL}[-] Jadx executable not found.{bcolors.ENDC}')
        return
    if not os.path.exists(output_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] Output directory does not exist.{bcolors.ENDC}')
        logger.info(
            f'{bcolors.OKBLUE}[+] Creating output directory: {output_dir}{bcolors.ENDC}')
        os.makedirs(output_dir)

    foldernames = []

    # Using ThreadPoolExecutor to process APK files concurrently
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Prepare the arguments for each task
        tasks = [(apk, output_dir, exec_path, additional_args)
                 for apk in folder]
        # Submit the tasks
        futures = [executor.submit(apk_to_java_single, *task)
                   for task in tasks]
        # Wait for tasks to complete and gather results
        for future in concurrent.futures.as_completed(futures):
            foldernames.append(future.result())
    return foldernames

def format_findings(findings, root):
    '''
    Formats findings

    Args:
        findings (dict): findings
        root (str): root path
    Returns:
        dict: formatted findings
    '''
    for details in findings.values():
        tmp_dict = {}
        for file_meta in details['files']:
            file_meta['file_path'] = file_meta[
                'file_path'].replace(root, '', 1)
            file_path = file_meta['file_path']
            start = file_meta['match_lines'][0]
            end = file_meta['match_lines'][1]
            if start == end:
                match_lines = start
            else:
                exp_lines = []
                for i in range(start, end + 1):
                    exp_lines.append(i)
                match_lines = ','.join(str(m) for m in exp_lines)
            if file_path not in tmp_dict:
                tmp_dict[file_path] = str(match_lines)
            elif tmp_dict[file_path].endswith(','):
                tmp_dict[file_path] += str(match_lines)
            else:
                tmp_dict[file_path] += ',' + str(match_lines)
        details['files'] = tmp_dict
    return findings


def scan(rule: str, extensions: str, paths: list, ignore_paths: list) -> dict:
    '''
    Scans the files using libsast library and returns findings in a dictionary format 

    Args:
        rule (str): rule file path
        extensions (str): extensions to scan
        paths (list): list of paths to scan
        ignore_paths (list): list of paths to ignore
    Returns:
        dict: findings
    '''
    try:
        options = {
            'match_rules': rule,
            'match_extensions': extensions,
            'ignore_paths': ignore_paths,
            'show_progress': True}

        scanner = Scanner(options, paths)
        res = scanner.scan()
        if res:
            return format_findings(res['pattern_matcher'], paths[0])
    except Exception:
        logger.exception('libsast scan')
    return {}


def extract_features_single(java_output_folder: str, OUTPUT_DIR: str) -> None:
    try:
        findings = scan(rule=API_RULES, extensions=['.java', '.kt'], paths=[
                        java_output_folder[0]], ignore_paths=SKIP_CLASS_PATH)
        with open(os.path.join(OUTPUT_DIR, java_output_folder[1] + '.json'), 'w') as f:
            json.dump(findings, f, indent=4)
        logger.info(
            f'{bcolors.OKGREEN}[+]Finished processing {java_output_folder[1]} folder {bcolors.ENDC}')
    except Exception:
        logger.exception('Error processing {}'.format(java_output_folder[1]))
        logger.info(
            f'{bcolors.OKGREEN}[+]Skipping {java_output_folder[1]}{bcolors.ENDC}')

def extract_features(java_output_folders : list, OUTPUT_DIR : str) -> None:
    '''
    Extracts features from Java files and saves them in JSON format

    Args:
        java_output_folders (list): list of java output folders
        OUTPUT_DIR (str): output directory
    Returns:
        None
    '''
    logger.info(
        f'{bcolors.OKBLUE}[+]Extracting features from Java files{bcolors.ENDC}')

    # Using ThreadPoolExecutor to process folders concurrently
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Prepare the arguments for each task
        tasks = [(folder, OUTPUT_DIR) for folder in java_output_folders]
        # Submit the tasks
        futures = [executor.submit(extract_features_single, *task)
                   for task in tasks]
        # Wait for tasks to complete
        concurrent.futures.wait(futures)
    logger.info(
        f'{bcolors.OKBLUE}[+]Finished extracting features from Java files{bcolors.ENDC}')
    
if __name__ == '__main__':

    parser = argparse.ArgumentParser(description="Process APKs in a folder and extract features")
    parser.add_argument(
       "-af", "--apk_folder",   help="Input Path to folder of APKs to be processed", type=str, required=True)
    parser.add_argument(
        "-o", "--output_folder",   help="Output Path to folder of APKs to be processed", type=str, required=False)
    parser.add_argument(
        "-u","--update",   help="Update jadx to latest version",type=bool, default=True, required=False)
    parser.add_argument(
        "-ax", "--additional", help="Additional arguments to be passed to jadx", type=str, default=None, required=False)
    args = parser.parse_args()
    download_latest_jadx(args.update)
    set_exec_path()
    if args.output_folder is None:
        OUTPUT_DIR = os.path.join(os.getcwd(), 'FeatureExtraction', 'Output')
    else:
        OUTPUT_DIR = args.output_folder
    apk_list = process_input_folder(args.apk_folder)
    java_output_folders = apk_to_java(apk_list, output_dir=OUTPUT_DIR,
                                      exec_path=EXEC_PATH, additional_args=args.additional)
    extract_features(java_output_folders, OUTPUT_DIR)
    cleanfolder(java_output_folders)

'''
-af D:\tcwork\apks\AndroRat\test -o SampleOutPut
'''
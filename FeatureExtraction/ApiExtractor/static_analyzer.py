import os
import csv
import sys
import json
import time
import shutil
import pathlib
import hashlib
import argparse
import platform
import subprocess
import pandas as pd
import seaborn as sns
import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor

from typing import List, Optional
from libsast import Scanner

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)


from libs._base_logger import logger, error_logger
from libs.color import bcolors
from ApiExtractor.jadx_updator import download_latest_jadx

EXEC_PATH = None
SKIP_CLASS_PATH = {
    'com/google/', 'androidx', 'okhttp2/', 'okhttp3/',
    'com/android/', 'com/squareup', 'okhttp/'
    'android/content/', 'com/twitter/', 'twitter4j/',
    'android/support/', 'org/apache/', 'oauth/signpost',
    'android/arch', 'org/chromium/', 'com/facebook',
    'org/spongycastle', 'org/bouncycastle',
    'com/amazon/identity/', 'io/fabric/sdk',
    'com/instabug', 'com/crashlytics/android',
    'kotlinx/', 'kotlin/', 'com/google/gson/', 'com/google/firebase/', 'com/google/ads/',
    'com/branch/sdk/', 'io/sentry/',
    'io/underscope/',
    'org/jsoup/', 'org/joda/', 'org/greenrobot/',
}
API_RULES = os.path.join(
    'FeatureExtraction', 'libs', 'Mobfs_api_ref', 'android_apis.yaml')


def set_exec_path() -> str:
    '''
    Sets the path to jadx executable based on the OS

    '''
    global EXEC_PATH
    if platform.system() == 'Windows':
        EXEC_PATH = os.path.join(
            'FeatureExtraction', 'libs', 'jadx', 'bin', 'jadx.bat')
    elif platform.system() == 'Linux':
        EXEC_PATH = os.path.join(
            'FeatureExtraction', 'libs', 'jadx', 'bin', 'jadx')
    return EXEC_PATH


def process_input_folder(app_dir: str) -> List[str]:
    '''
    Finds all the APKs in a directory and genrates full path to each APK

    Args:
        app_dir (str): path to folder containing APKs
        Returns:
            list: list of APKs

    '''
    if not os.path.exists(app_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] The folder does not exist.{bcolors.ENDC}')
        return
    if not os.path.isdir(app_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] The provided path is not a folder.{bcolors.ENDC}')
        return

    logger.info(
        f'{bcolors.OKBLUE}[+] Looking for APKs in: {app_dir}{bcolors.ENDC}')
    apk_list = []
    for root, dirs, files in os.walk(app_dir):
        for file in files:
            if file.endswith('.apk'):
                # MAKE IT POSIX PATH
                apk_list.append(pathlib.PurePath(root, file).as_posix())
                logger.info(
                    f'{bcolors.OKBLUE}[+] Found APK: {file}{bcolors.ENDC}')
    logger.info(
        f'{bcolors.OKBLUE}[+] Total APKs found: {len(apk_list)}{bcolors.ENDC}')
    return apk_list


def cleanfolder(folder: List[str]):
    '''
    Cleans up the folder

    Args:
        folder (list): list of folders
    '''
    for paths in folder:
        shutil.rmtree(paths[0])
        logger.info(
            f'{bcolors.OKGREEN}[+] Deleted folder: {paths[1]}{bcolors.ENDC}')


def apk_to_java_single(args) -> dict:
    apk, output_dir, exec_path, additional_args = args
    '''
    Converts a single APK to Java

    Args:
        apk (str): path to APK
        output_dir (str): path to output directory
        exec_path (str): path to jadx executable
        additional_args (str): additional arguments to jadx
    Returns:
        dict: dictionary containing the path to the output folder and the name of the folder
    '''
    with open(apk, 'rb') as f:
        bytes = f.read()
        apk_hash = hashlib.sha256(bytes).hexdigest()
        apk_size = os.path.getsize(apk)
    foldername = os.path.basename(apk)

    foldername = os.path.splitext(foldername)[0]+'_API'
    foldername = foldername.replace(' ', '_')
    current_apk_output_dir = os.path.join(output_dir, foldername)
    if not os.path.exists(current_apk_output_dir):
        os.makedirs(current_apk_output_dir)

    logger.info(
        f'{bcolors.OKBLUE}[+] Converting APK to Java: {foldername}{bcolors.ENDC}')

    if additional_args is None:
        command = [exec_path, '-ds', current_apk_output_dir,
                   '-r', '--show-bad-code', '--deobf', apk]
    else:
        command = [exec_path, '-ds', current_apk_output_dir, '-r',
                   '--show-bad-code', '--deobf', apk, additional_args]
    start_time = time.time()
    with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        for line in proc.stdout:
            logger.info(
                f'{bcolors.OKGREEN}{line.decode().strip()}{bcolors.ENDC}')
        for line in proc.stderr:
            error_logger.error(
                f'{bcolors.FAIL}{line.decode().strip()}{bcolors.ENDC}')
    logger.info(
        f'{bcolors.OKBLUE}[+] Finished converting APK to Java: {foldername}{bcolors.ENDC}')
    jadx_time = time.time() - start_time
    return {
        'folder': (current_apk_output_dir, foldername),
        'apk_hash': apk_hash,
        'apk_size': apk_size,
        'jadx_time': jadx_time
    }


def apk_to_java(folder: List[str], output_dir: str, exec_path: Optional[str] = None, additional_args: Optional[str] = None) -> List[str]:
    '''
        Converts APK to Java using Jadx

        Args:
            folder (list): list of APKs
            output_dir (str): output directory
            exec_path (str): path to jadx executable
            additional_args (str): additional arguments to pass to jadx
        Returns:
            list: list of folder names
    '''
    if not os.path.exists(exec_path):
        error_logger.error(
            f'{bcolors.FAIL}[-] Jadx executable not found.{bcolors.ENDC}')
        return
    if not os.path.exists(output_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] Output directory does not exist.{bcolors.ENDC}')
        logger.info(
            f'{bcolors.OKBLUE}[+] Creating output directory: {output_dir}{bcolors.ENDC}')
        os.makedirs(output_dir)

    # Prepare the arguments for each task
    tasks = [(apk, output_dir, exec_path, additional_args) for apk in folder]

    # Create a pool of processes and map the tasks to it
    with mp.Pool() as pool:
        results = pool.map(apk_to_java_single, tasks)

    return results


def format_findings(findings, root):
    '''
    Formats findings

    Args:
        findings (dict): findings
        root (str): root path
    Returns:
        dict: formatted findings
    '''
    for details in findings.values():
        tmp_dict = {}
        for file_meta in details['files']:
            file_meta['file_path'] = file_meta[
                'file_path'].replace(root, '', 1)
            file_path = file_meta['file_path']
            start = file_meta['match_lines'][0]
            end = file_meta['match_lines'][1]
            if start == end:
                match_lines = start
            else:
                exp_lines = []
                for i in range(start, end + 1):
                    exp_lines.append(i)
                match_lines = ','.join(str(m) for m in exp_lines)
            if file_path not in tmp_dict:
                tmp_dict[file_path] = str(match_lines)
            elif tmp_dict[file_path].endswith(','):
                tmp_dict[file_path] += str(match_lines)
            else:
                tmp_dict[file_path] += ',' + str(match_lines)
        details['files'] = tmp_dict
    return findings


def scan(rule: str, extensions: str, paths: list, ignore_paths: list) -> dict:
    '''
    Scans the files using libsast library and returns findings in a dictionary format

    Args:
        rule (str): rule file path
        extensions (str): extensions to scan
        paths (list): list of paths to scan
        ignore_paths (list): list of paths to ignore
    Returns:
        dict: findings
    '''
    try:
        options = {
            'match_rules': rule,
            'match_extensions': extensions,
            'ignore_paths': ignore_paths,
            'show_progress': True}

        scanner = Scanner(options, paths)
        res = scanner.scan()
        if res:
            return format_findings(res['pattern_matcher'], paths[0])
    except Exception:
        logger.exception('libsast scan')
    return {}


def extract_features_single(args) -> None:
    java_output_folder, OUTPUT_DIR = args
    '''
    Extracts features from Java files

    Args:
        java_output_folder (str): path to Java files
        OUTPUT_DIR (str): output directory
    '''

    java_save_folder = java_output_folder["folder"]
    start_time = time.time()

    try:
        findings = scan(rule=API_RULES, extensions=['.java', '.kt'], paths=[
                        java_save_folder[0]], ignore_paths=SKIP_CLASS_PATH)
        with open(os.path.join(OUTPUT_DIR, java_save_folder[1] + '.json'), 'w') as f:
            json.dump(findings, f, indent=4)
        logger.info(
            f'{bcolors.OKGREEN}[+]Finished processing {java_save_folder[1]} folder {bcolors.ENDC}')
    except Exception:
        logger.exception('Error processing {}'.format(java_save_folder[1]))
        logger.info(
            f'{bcolors.OKGREEN}[+]Skipping {java_save_folder[1]}{bcolors.ENDC}')
    java_output_folder['libsast_time'] = time.time() - start_time
    java_output_folder['java_size'] = sum(os.path.getsize(
        f) for root, dirs, files in os.walk(java_save_folder[0]) for f in map(lambda x: os.path.join(root, x), files))
    return java_output_folder


def extract_features(java_output_folders: list, OUTPUT_DIR: str) -> None:
    '''
    Extracts features from Java files and saves them in JSON format

    Args:
        java_output_folders (list): list of java output folders
        OUTPUT_DIR (str): output directory
    Returns:
        None
    '''
    logger.info(
        f'{bcolors.OKBLUE}[+]Extracting features from Java files{bcolors.ENDC}')

   # Prepare the arguments for each task
    tasks = [(folder, OUTPUT_DIR) for folder in java_output_folders]

    # Create a pool of processes and map the tasks to it
    with mp.Pool() as pool:
        results = pool.map(extract_features_single, tasks)

    logger.info(
        f'{bcolors.OKBLUE}[+]Finished extracting features from Java files{bcolors.ENDC}')
    return results


def write_report(data: list, file_name: str) -> None:
    '''
    Writes the final report to a CSV file using pandas

    Args:
        data (list): list of dictionaries containing the data
        file_name (str): the name of the file to be saved as

    '''
    # Extract the second element from each 'folder' tuple in data
    for item in data:
        item['folder'] = item['folder'][1]

    # Convert the data to a DataFrame
    df = pd.DataFrame(data)

    # Write the DataFrame to a CSV file
    df.to_csv(file_name, index=False)
    logger.info(
        f'{bcolors.OKGREEN}[+]Report saved to {file_name}{bcolors.ENDC}')


def plot_graphs(file_name: str, OUTPUT_DIR: str) -> None:
    '''
    Plots graphs using seaborn and matplotlib

    Args:
        file_name (str): the name of the file to be saved as
        OUTPUT_DIR (str): output directory
    Returns:
        None

    '''
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    if not os.path.exists(os.path.join(OUTPUT_DIR, "plots")):
        os.makedirs(os.path.join(OUTPUT_DIR, "plots"))
    logger.info(
        f'{bcolors.OKBLUE}[+]Plotting graphs{bcolors.ENDC}')
    # Load the data
    df = pd.read_csv(file_name)

    # Convert bytes to MB
    df['apk_size'] = df['apk_size'] / (1024 * 1024)  # 1 Byte = 1/1024^2 MB
    df['java_size'] = df['java_size'] / (1024 * 1024)

    # Set the style
    sns.set_style("whitegrid")

    # Plot apk_size vs jadx_time
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=df, x='apk_size', y='jadx_time')
    plt.title('APK Size vs Jadx Time', fontsize=20)
    plt.xlabel('APK Size (MB)', fontsize=15)
    plt.ylabel('Jadx Time (seconds)', fontsize=15)
    plt.savefig(os.path.join(OUTPUT_DIR, "plots", 'apk_size_vs_jadx_time.png'))
    logger.info(
        f'{bcolors.OKGREEN}[+]Plot saved to {os.path.join(OUTPUT_DIR,"plots" , "apk_size_vs_jadx_time.png")}{bcolors.ENDC}')

    # Plot libsast_time vs java_size
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=df, x='java_size', y='libsast_time')
    plt.title('Java Size vs Libsast Time', fontsize=20)
    plt.xlabel('Java Size (MB)', fontsize=15)
    plt.ylabel('Libsast Time (seconds)', fontsize=15)
    plt.savefig(os.path.join(OUTPUT_DIR, "plots",
                'java_size_vs_libsast_time.png'))
    logger.info(
        f'{bcolors.OKGREEN}[+]Plot saved to {os.path.join(OUTPUT_DIR, "plots" ,"java_size_vs_libsast_time.png")}{bcolors.ENDC}')


if __name__ == '__main__':
    START_TIME = time.time()

    parser = argparse.ArgumentParser(
        description="Process APKs in a folder and extract features")
    parser.add_argument(
        "-af", "--apk_folder",   help="Input Path to folder of APKs to be processed", type=str, required=True)
    parser.add_argument(
        "-o", "--output_folder",   help="Output Path to folder of APKs to be processed", type=str, required=False)
    parser.add_argument(
        "-u", "--update",   help="Update jadx to latest version", type=bool, default=True, required=False)
    parser.add_argument(
        "-ax", "--additional", help="Additional arguments to be passed to jadx", type=str, default=None, required=False)
    args = parser.parse_args()
    download_latest_jadx(args.update)
    set_exec_path()
    if args.output_folder is None:
        OUTPUT_DIR = os.path.join(os.getcwd(), 'FeatureExtraction', 'Output')
    else:
        OUTPUT_DIR = args.output_folder
    apk_list = process_input_folder(args.apk_folder)
    java_output_folders = apk_to_java(apk_list, output_dir=OUTPUT_DIR,
                                      exec_path=EXEC_PATH, additional_args=args.additional)
    results = extract_features(java_output_folders, OUTPUT_DIR)

    # Clean up folders and write report
    cleanfolder([result['folder'] for result in results])
    report_name = os.path.basename(os.path.normpath(args.apk_folder)) + '.csv'
    report_path = os.path.join(OUTPUT_DIR, report_name)
    write_report(results, report_path)
    plot_graphs(report_path, OUTPUT_DIR)
    END_TIME = time.time()
    logger.info(
        f'{bcolors.OKGREEN}[+]Total time taken: {END_TIME - START_TIME} seconds{bcolors.ENDC}')

'''
-af D:\tcwork\apks\AndroRat\test -o SampleOutPut
'''


import os
import sys
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

sys.path.append(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.libs.streamlit_libs import *
from src.feature_selection.vectorizer import process_files
from src.libs.docker_api import main_s
from src.libs._base_logger import logger,error_logger
from src.libs.color import bcolors

# App layout
st.set_page_config(page_title="Vectorize and Serve",
                   layout="wide", page_icon="ðŸ“Š")


apply_custom_css()

st.write(f"# Vectorize and Serve TensorFlow Model")
st.write(f"## File name: {st.session_state['current_apk_name']}")
if st.button("Run Vectorizer"):
    logger.info(
        f"{bcolors.OKGREEN}[+] Running Vectorizer on {st.session_state['current_apk_name']}{bcolors.ENDC}")
    input_folder = os.path.join(
        streamlit_app_output, st.session_state["current_apk_hash"])
    vectors = process_files(input_folder, True, True)
    names = ["API_VECTORS", "INTENT_VECTORS",
             "PERMISSION_VECTORS", "MERGED_VECTORS"]
    # Print vectors and names
    for vector, name in zip(vectors, names):
        st.markdown(f"## {name}")
        st.json(vector, expanded=False)
        st.markdown("---")
    logger.info(
        f"{bcolors.OKGREEN}[+] Vectorizer ran successfully{bcolors.ENDC}")
    st.success("Vectorizer ran successfully")
    st.markdown("---")
    st.markdown("## Serving the model")
    logger.info(
        f"{bcolors.OKGREEN}[+] Serving the model{bcolors.ENDC}")
    with st.spinner('Please wait for the model to serve...'):
        returned_data = main_s(vectors)
    logger.info(
        f"{bcolors.OKGREEN}[+] Model served successfully{bcolors.ENDC}")
    st.success("Model served successfully")
    st.markdown("## The output is: ")

    # Define x-axis multicategories
    x = [
        ["Dataset", "Dataset", "Dataset", "Dataset"],
        returned_data['Dataset'].tolist()
    ]

    # Define y-axis values
    y1 = returned_data['Confidence Score'].tolist()
    # Assuming the second bar represents the 'benign' confidence
    y2 = [1 - y for y in y1]

    # Create a bar chart
    fig = go.Figure()

    # Add bars for 'malware' confidence
    fig.add_bar(x=x, y=y1, name="Malware Confidence", marker_color='#FF6363')

    # Add bars for 'benign' confidence
    fig.add_bar(x=x, y=y2, name="Benign Confidence", marker_color='#6495ED')
    # Update layout
    fig.update_layout(barmode="relative")

    # Display the chart in Streamlit
    st.plotly_chart(fig)

    # print last row  as string only value
    last_row = returned_data.values[-1:]
    list_a = last_row.tolist()
    list_a = list_a[0]
    logger.info(
        f"{bcolors.OKGREEN}[+] The output is: {list_a}{bcolors.ENDC}")

    if "Malware" in list_a[2]:
        labels = ['Malware', 'Benign']
        values = [list_a[1], 1-list_a[1]]
        color_discrete_sequence = ['#FF6363', '#6495ED']
        txt_color = f'<span style="color:#FF6363"> {list_a[2]} </span>'

    else:
        labels = ['Benign', 'Malware']
        values = [1-list_a[1], list_a[1]]
        color_discrete_sequence = ['#6495ED', '#FF6363']
        txt_color = f'<span style="color:#6495ED"> {list_a[2]} </span>'

    output_statement = f"## The {list_a[0]} for the app '{st.session_state['current_apk_hash']}.apk 'is {txt_color} ({list_a[1]})"
    st.markdown(output_statement, unsafe_allow_html=True)

    st.markdown("---")

    # Pie Chart

    # Assuming that the confidence score is a percentage
    st.markdown("## Final Classification")
    fig_pie = px.pie(values=values, names=labels,  hole=.3,
                     color_discrete_sequence=color_discrete_sequence)  # specify colors in the same order as labels

    st.plotly_chart(fig_pie)
st.markdown("---")

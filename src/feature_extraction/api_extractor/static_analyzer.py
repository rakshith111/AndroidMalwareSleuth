import os
import sys
import json
import time
import shutil
import hashlib
import argparse
import platform
import subprocess
import pandas as pd

from typing import List, Optional
from libsast import Scanner

sys.path.append(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from libs.color import bcolors
from libs._base_logger import logger, error_logger, ROOT_DIR
from libs.jadx_updater import download_latest_jadx

EXEC_PATH = None
SKIP_CLASS_PATH = {
    'com/google/', 'androidx/', 'okhttp2/', 'okhttp3/',
    'com/android/', 'com/squareup', 'okhttp/'
    'android/content/', 'com/twitter/', 'twitter4j/',
    'android/support/', 'org/apache/', 'oauth/signpost',
    'android/arch', 'org/chromium/', 'com/facebook',
    'org/spongycastle', 'org/bouncycastle',
    'com/amazon/identity/', 'io/fabric/sdk',
    'com/instabug', 'com/crashlytics/android',
    'kotlinx/', 'kotlin/', 'com/google/gson/', 'com/google/firebase/', 'com/google/ads/',
    'com/branch/sdk/', 'io/sentry/',
    'io/underscope/',
    'org/jsoup/', 'org/joda/', 'org/greenrobot/',
}
API_RULES = os.path.normpath(os.path.join(
    ROOT_DIR, 'libs', 'mobfs', 'android_apis.yaml'))

def set_exec_path() -> str:
    ''' 
    Sets the path to jadx executable based on the OS


    Returns:
        str: path to jadx executable
    '''
    global EXEC_PATH
    if platform.system() == 'Windows':
        EXEC_PATH = os.path.join(ROOT_DIR, 'libs', 'jadx', 'bin', 'jadx.bat')

    elif platform.system() == 'Linux':
        EXEC_PATH = os.path.join(ROOT_DIR, 'libs', 'jadx', 'bin', 'jadx')
    return os.path.normpath(EXEC_PATH)


def process_input_folder(app_dir: str) -> List[str]:
    '''
    Finds all the APKs in a directory and genrates full path to each APK


    Args:
        app_dir (str): path to the directory containing APKs

    Returns:
        List[str]: list of full paths to APKs
    '''
    if not os.path.exists(app_dir):
        error_logger.error(
            f'{bcolors.FAIL}[-] The folder does not exist.{bcolors.ENDC}')
        exit(1)
    if not os.path.isdir(app_dir):
        error_logger.error(
            f'{bcolors.WARNING}[-] The provided path is not a folder.{bcolors.ENDC}')
        exit(1)
    logger.info(
        f'{bcolors.OKBLUE}[+] Looking for APKs in: {app_dir}{bcolors.ENDC}')
    apk_list = []
    for root, dirs, files in os.walk(app_dir):
        for file in files:
            if file.endswith('.apk'):
                apk_list.append(os.path.normpath(os.path.join(root, file)))
                logger.info(
                    f'{bcolors.OKBLUE}[+] Found APK: {file}{bcolors.ENDC}')
    logger.info(
        f'{bcolors.OKBLUE}{bcolors.UNDERLINE}[+] Total APKs found: {len(apk_list)}{bcolors.ENDC}')
    return apk_list


def apk_to_java_single(args) -> dict:
    apk, output_folder, exec_path, additional_args = args

    '''
    Converts a single APK to Java

    Args:
        args (list): list containing the path to APK, output directory, jadx executable path and additional arguments
            apk (str): path to APK
            output_folder (str): path to output directory
            exec_path (str): path to jadx executable
            additional_args (str): additional arguments to jadx
    Returns:
        Dict: dictionary containing the path to output directory, folder name and APK hash
        
    '''
    with open(apk, 'rb') as f:
        bytes = f.read()
        apk_hash = hashlib.sha256(bytes).hexdigest()
        apk_size = os.path.getsize(apk)
    foldername = os.path.basename(apk)
    foldername = os.path.splitext(foldername)[0]+'_API'
    foldername = foldername.replace(' ', '_')
    apk_output_dir = os.path.join(output_folder, foldername)
    apk_output_dir = os.path.normpath(apk_output_dir)

    if not os.path.exists(apk_output_dir):
        os.makedirs(apk_output_dir)

    logger.info(
        f'{bcolors.HEADER}{bcolors.UNDERLINE}[+] Converting APK to Java: {foldername}{bcolors.ENDC}')
    if additional_args is None:
        command = [exec_path, '-ds', apk_output_dir,
                   '-r', '--deobf', '-j', '3', apk]
    else:
        command = [exec_path, '-ds', apk_output_dir, '-r',
                   '--deobf', '-j', '3', apk, additional_args]

    start_time = time.time()
    with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        for line in proc.stdout:
            logger.info(
                f'{bcolors.OKGREEN}{line.decode().strip()}{bcolors.ENDC}')
        for line in proc.stderr:
            error_logger.error(
                f'{bcolors.FAIL}{line.decode().strip()}{bcolors.ENDC}')
    logger.info(
        f'{bcolors.OKBLUE}[+] Finished converting APK to Java: {foldername}{bcolors.ENDC}')
    jadx_time = time.time() - start_time
    return {
        'folder': (apk_output_dir, foldername),
        'apk_hash': apk_hash,
        'apk_size': apk_size,
        'jadx_time': jadx_time
    }


def apk_to_java(folder: List[str], output_dir: str, exec_path: Optional[str] = None, additional_args: Optional[str] = None) -> List[str]:
    '''
    Converts a list of APKs to Java using jadx

    Args:
        folder (List[str]): List of APKs
        output_folder (str): Output Folder name
        exec_path (Optional[str], optional): Path to jadx executable. Defaults to None.
        additional_args (Optional[str], optional): Additional arguments to pass to jadx. Defaults to None.

    Returns:
        List[str]: List of folder names
    '''

    if not os.path.exists(exec_path):
        error_logger.error(
            f'{bcolors.WARNING}[-] Jadx executable not found.{bcolors.ENDC}')
        return
    if not os.path.exists(output_dir):
        error_logger.error(
            f'{bcolors.WARNING}[*] Output directory does not exist.{bcolors.ENDC}')
        logger.info(
            f'{bcolors.OKBLUE}[+] Creating output directory: {output_dir}{bcolors.ENDC}')
        os.makedirs(output_dir)

    # Prepare the arguments for each task
    tasks = [(apk, output_dir, exec_path, additional_args) for apk in folder]

    # Run the tasks one by one for now
    # ADD THREADING HERE
    results = []
    for task in tasks:
        results.append(apk_to_java_single(task))

    return results


def format_findings(findings: dict, root: str) -> dict:
    '''
    Formats findings
    Args:
        findings (dict): Findings
        root (str): Root path
    Returns:
        dict: Formatted findings
    '''
    for details in findings.values():
        tmp_dict = {}
        for file_meta in details['files']:
            file_path = file_meta['file_path'].replace(root, '', 1)
            start = file_meta['match_lines'][0]
            end = file_meta['match_lines'][1]
            if start == end:
                match_lines = str(start)
            else:
                exp_lines = [str(i) for i in range(start, end + 1)]
                match_lines = ','.join(exp_lines)
            tmp_dict.setdefault(file_path, []).append(match_lines)

        details['files'] = {file_path: ','.join(
            lines) for file_path, lines in tmp_dict.items()}

    return findings


def scan(rule: str, extensions: str, paths: list, ignore_paths: list) -> dict:
    '''
    Scans a list of paths for a given rule

    Args:
        rule (str): Scan rule
        extensions (str): Extensions to scan
        paths (list): List of paths to scan
        ignore_paths (list): List of paths to ignore

    Returns:
        dict: Findings
    '''
    try:
        options = {
            'match_rules': rule,
            'match_extensions': extensions,
            'ignore_paths': ignore_paths,
            'show_progress': True}

        scanner = Scanner(options, paths)
        logger.info(f'{bcolors.OKBLUE}[+] Scanning {paths[0]}{bcolors.ENDC}')
        result = scanner.scan()
        if result:
            return format_findings(result['pattern_matcher'], paths[0])
    except Exception as e:
        logger.exception(
            f'{bcolors.FAIL}[-] Error while scanning. {e} {bcolors.ENDC}')
    return {}


def extract_features_single(args) -> None:
    java_output_folder, OUTPUT_DIR = args
    '''
    Extracts features from Java files

    Args:
        Args (tuple): Tuple containing java_output_folder and OUTPUT_DIR
            java_output_folder (str): path to Java files
            OUTPUT_DIR (str): output directory
   '''

    java_save_folder = java_output_folder["folder"]
    start_time = time.time()

    try:
        findings = scan(rule=API_RULES, extensions=['.java', '.kt'], paths=[
                        java_save_folder[0]], ignore_paths=SKIP_CLASS_PATH)
        with open(os.path.join(OUTPUT_DIR, java_save_folder[1] + '.json'), 'w', encoding="utf-8") as f:
            json.dump(findings, f, indent=4)
        logger.info(
            f'{bcolors.OKGREEN}[+] Finished processing {java_save_folder[1]} folder {bcolors.ENDC}')
    except Exception:
        logger.exception('Error processing {}'.format(java_save_folder[1]))
        logger.info(
            f'{bcolors.OKGREEN}[+] Skipping {java_save_folder[1]}{bcolors.ENDC}')
    java_output_folder['libsast_time'] = time.time() - start_time    
    # Get the size of the folder problem with long path
    java_output_folder['java_size'] = shutil.disk_usage(java_save_folder[0]).used
    return java_output_folder


def extract_features(java_output_folders: list, OUTPUT_DIR: str) -> None:
    '''
    Extracts features from Java files

    Args:
        java_output_folders (list): List of tuples containing java_output_folder and OUTPUT_DIR
        OUTPUT_DIR (str): Output directory
    '''
    logger.info(
        f'{bcolors.HEADER}{bcolors.UNDERLINE}[+] Extracting features from Java files{bcolors.ENDC}')

   # Prepare the arguments for each task
    tasks = [(folder, OUTPUT_DIR) for folder in java_output_folders]

   # Run the tasks one by one for now
    # ADD THREADING HERE
    results = []
    for task in tasks:
        results.append(extract_features_single(task))

    logger.info(
        f'{bcolors.OKBLUE}{bcolors.UNDERLINE}[+] Finished extracting features from Java files{bcolors.ENDC}')
    return results


def write_report(data: list, file_name: str) -> None:
    '''
    Writes the report to a CSV file

    Args:
        data (list): List of dictionaries containing the report data
        file_name (str): Name of the file to be saved as
    '''

    # Extract the second element from each 'folder' tuple in data
    for item in data:
        item['folder'] = item['folder'][1]

    # Convert the data to a DataFrame
    df = pd.DataFrame(data)

    # Write the DataFrame to a CSV file
    df.to_csv(file_name, index=False)
    logger.info(
        f'{bcolors.OKGREEN}{bcolors.UNDERLINE}[+] Report saved to : {file_name}{bcolors.ENDC}')


def plot_graphs(file_name: str, output_dir: str) -> None:
    '''
    Plots graphs

    Args:
        file_name (str): Name of the CSV file containing the report data
        output_dir (str): Output directory
    '''
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np
    import seaborn as sns

    if not os.path.exists(os.path.join(output_dir, "plots")):
        os.makedirs(os.path.join(output_dir, "plots"))
    logger.info(
        f'{bcolors.HEADER}[+] Plotting graphs{bcolors.ENDC}')
    # Load the data
    df = pd.read_csv(file_name)

    # Convert bytes to MB
    df['apk_size'] = df['apk_size'] / (1024 * 1024)  # 1 Byte = 1/1024^2 MB
    df['java_size'] = df['java_size'] / (1024 * 1024)
    if len(df) > 1:
    # Set the style
        sns.set_style("whitegrid")

        # Plot apk_size vs jadx_time
        plt.figure(figsize=(10, 6))
        sns.lineplot(data=df, x='apk_size', y='jadx_time')
        plt.title('APK Size vs Jadx Time', fontsize=20)
        plt.xlabel('APK Size (MB)', fontsize=15)
        plt.ylabel('Jadx Time (seconds)', fontsize=15)
        plt.savefig(os.path.join(output_dir, "plots", 'apk_size_vs_jadx_time.png'))
        logger.info(
            f'{bcolors.OKGREEN}{bcolors.UNDERLINE}[+] Plot saved to : {os.path.join(output_dir,"plots" , "apk_size_vs_jadx_time.png")}{bcolors.ENDC}')

        # Plot libsast_time vs java_size
        plt.figure(figsize=(10, 6))
        sns.lineplot(data=df, x='java_size', y='libsast_time')
        plt.title('Java Size vs Libsast Time', fontsize=20)
        plt.xlabel('Java Size (MB)', fontsize=15)
        plt.ylabel('Libsast Time (seconds)', fontsize=15)
        plt.savefig(os.path.join(output_dir, "plots",
                    'java_size_vs_libsast_time.png'))
        logger.info(
            f'{bcolors.OKGREEN}{bcolors.UNDERLINE}[+] Plot saved to : {os.path.join(output_dir, "plots" ,"java_size_vs_libsast_time.png")}{bcolors.ENDC}')
    else:
        sns.set_style('whitegrid')
        sns.set_palette('Set2')

        # Calculate the bar positions
        
        bar_width = 0.35
        group_spacing = 0.2
        group_count = len(df)
        bar_per_group = 2
        total_bar_width = bar_width * bar_per_group + group_spacing * (bar_per_group - 1)
        bar_positions = np.arange(group_count) * (total_bar_width)

        # Create the grouped bar plot
        plt.bar(bar_positions, df['libsast_time'], width=bar_width, label='libsast_time')
        plt.bar(bar_positions + bar_width + group_spacing, df['jadx_time'], width=bar_width,  label='jadx_time')

        # Set the x-axis ticks and labels
        plt.xticks(bar_positions + bar_width / 2, df['apk_size'])
        plt.xlabel('Size (MB)')
        plt.ylabel('Time')
        plt.title('Time vs Size')

        plt.legend()
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, "plots",
                    'time_vs_data_size.png'))
        logger.info(
            f'{bcolors.OKGREEN}{bcolors.UNDERLINE}[+] Plot saved to : {os.path.join(output_dir, "plots" ,"time_vs_data_size.png")}{bcolors.ENDC}')
        


def clean_folder(folder: List[str]) -> None:
    '''
    Deletes the folders created by jadx

    Args:
        folder (List[str]): List of folders to be deleted

    '''

    try:
        for remove_paths in folder:
            if platform.system() == 'Windows':

                subprocess.run(['rd', '/s', '/q', remove_paths[0]], shell=True)
            elif platform.system() == 'Linux':
                subprocess.run(['rm', '-rf', remove_paths[0]])
            logger.info(
            f'{bcolors.OKGREEN}[+] Deleted folder: {remove_paths[1]}{bcolors.ENDC}')
    except Exception as e:
        error_logger.error(
            f'{bcolors.FAIL}[-] Error deleting folder: {remove_paths[0]}\n Cause: {e} {bcolors.ENDC}')
        


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description="Process APKs in a folder and extract features")
    parser.add_argument(
        "-af", "--apk_folder",   help="Input Path to folder of APKs to be processed", type=str, required=True)
    parser.add_argument(
        "-o", "--output_folder",   help="Output Path to folder of APKs to be processed", type=str, required=True)
    parser.add_argument(
        "-u", "--update",   help="Update jadx to latest version", type=bool, default=True, required=False)
    parser.add_argument(
        "-ax", "--additional", help="Additional arguments to be passed to jadx", type=str, default=None, required=False)
    args = parser.parse_args()
    START_TIME = time.time()
    download_latest_jadx(args.update)
    set_exec_path()
    OUTPUT_DIR = args.output_folder
    apk_list = process_input_folder(args.apk_folder)
    java_output_folders = apk_to_java(apk_list, output_dir=OUTPUT_DIR,
                                      exec_path=EXEC_PATH, additional_args=args.additional)
    results = extract_features(java_output_folders, OUTPUT_DIR)
    # Clean up folders and write report
    clean_folder([result['folder'] for result in results])
    report_name = os.path.basename(os.path.normpath(args.apk_folder)) + '.csv'
    report_path = os.path.join(OUTPUT_DIR, report_name)
    write_report(results, report_path)
    plot_graphs(report_path, OUTPUT_DIR)
    END_TIME = time.time()
    logger.info(
        f'{bcolors.OKGREEN}[+] Total time taken: {END_TIME - START_TIME} seconds{bcolors.ENDC}')

'''
Try this command:
-af apk/folder -o SampleOutPut
'''
